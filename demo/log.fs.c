/****************************************************************************************************************************

	log.fs - Модуль облегченной "файловой системы" для записи логов в "черном ящике".

*****************************************************************************************************************************/

#include "log.fs.h"
#include "log.fs.platformdepend.h"


/*----------------------------------- Приватная часть модуля---------------------------------------------------------------------*/


/************************************************************
	Управляющая структура для работы файловой системы
************************************************************/
struct {
	uint16_t files;                 // Количество файлов на диске
	uint16_t freeSectors;           // Количество свободных секторов
	uint16_t lastFileBegin;         // Сектор с последним созданным файлом
	uint16_t lastFileSectors;       // Количество секторов, которые занимает последний созданный файл
	uint16_t firstFileBegin;        // Самый старый файл на диске
	uint16_t firstFileSectors;      // Количество секторов, которые занимает самый старый созданный файл
	uint16_t currentFileSector;     // Свободный сектор, где можно создать новый файл
	uint32_t cursorPosition;        // Позиция в файле для записи
	LogFs_Status state;
} core = { 0,FS_SECTORS_NUM,0,0,0,0,0,0,FS_NOT_INIT };

/************************************************************
	Структура для обеспечения доступа к файлам
************************************************************/
struct {
	uint32_t id;                     // Порядковый номер файла
	uint32_t size;                   // Размер файла в байтах
	uint16_t sectors;                // Число секторов на которых размещен файл
	uint16_t begin;                  // Стартовый сектор файла
	LogFs_Status state;              // Статус селектора
} fileSelector = { 0,0,0,0,FS_NOT_INIT };


/***************************************************************************************************
	LogFs_deleteOldestFile - Функция Удаления самого старого файла в директории. Является
	приватной, ее самостоятельный вызов может привести к ошибке файловой системы.

	Примечание:  В случае полной заполненности памяти, при создании файла - произойдет вызов
	этой функции. Она удалит самый старый из имеющихся файлов и произведет очистку секторов,
	которые он занимал.

	Возвращает:
				FS_SUCCESS  - Файл был удачно удален из директории
				FS_ERROR - Неизвестное форматирование (файловая система имеет внутреннюю ошибку
***************************************************************************************************/
static LogFs_Status LogFs_deleteOldestFile(void);


/***************************************************************************************************
	LogFs_getNumberSectorsFile - Узнать количество секторов которые занимает файл c началом
	в секторе с номером Sector;
	Параметры:
				Sector - Номер сектора в котором начинается файл (от 0 до FS_SECTORS_NUM - 1)
	Возвращает:
				Количество секторов которые занимает файл
***************************************************************************************************/
static uint16_t LogFs_getNumberSectorsFile(uint16_t Sector);



/*------------------------------------------Публичная часть модуля-------------------------------------------------------------*/



/***************************************************************************************************
	LogFs_format - Форматирование накопителя (полная очистка с потерей всех данных)
***************************************************************************************************/
void LogFs_format(void)
{
	eraseChip();
}


/***************************************************************************************************
	LogFs_getFileNumber - Получение информации о числе имеющихся файлов в директории
***************************************************************************************************/
uint16_t LogFs_getFileNumber(void)
{
	return core.files;
}



/***************************************************************************************************
	LogFs_getLastFileId - Узнать порядковый номер последнего созданного файла
***************************************************************************************************/
uint16_t LogFs_getLastFileId(void)
{
	uint32_t address;               // Вычисляемый адрес для чтения
	uint8_t  buffer[HANDLER_SIZE];  // Буфер для чтения заголовка и номера файла
	uint16_t i;                     // Счетчик циклов

	// Если файловая система не инициализирована, то выходим
	if (core.state != FS_INIT_DONE && core.state != FS_FILE_OPEN)
		return 0;

	for (i = 0; i < HANDLER_SIZE; i++) 
		buffer[i] = 0;

	// Определяем стартовый адрес расположения последнего созданного файла
	address = FS_SECTOR_SIZE * core.lastFileBegin;
	// Читаем залоговок и номер файла
	readMemory(address, buffer, HANDLER_SIZE);

	// Возвращаем порядкой номер файла
	return *(uint16_t*)(buffer + 2);
}



/***************************************************************************************************
	LogFs_getCurrentFileId - Узнать порядковый номер открытого на запись файла
***************************************************************************************************/
uint16_t LogFs_getCurrentFileId(void)
{
	uint32_t address;                // Вычисляемый адрес для чтения
	uint8_t  buffer[HANDLER_SIZE];   // Буфер для чтения заголовка и номера файла
	uint16_t i;                      // Счетчик циклов

	// Если файловая система не инициализирована, то выходим
	if (core.state != FS_INIT_DONE && core.state != FS_FILE_OPEN)
		return 0;

	for (i = 0; i < HANDLER_SIZE; i++) 
		buffer[i] = 0;

	// Определяем стартовый адрес расположения последнего созданного файла
	address = FS_SECTOR_SIZE * core.currentFileSector;
	// Читаем залоговок (2 байта) и номер файла (2 байта)
	readMemory(address, buffer, HANDLER_SIZE);

	// Возвращаем порядковый номер файла
	return *(uint16_t*)(buffer + 2);
}




/***************************************************************************************************
	LogFs_getNumberSectorsFile - Узнать количество секторов которые занимает файл c началом
	в секторе с номером Sector
***************************************************************************************************/
static uint16_t LogFs_getNumberSectorsFile(uint16_t sector)
{
	uint32_t address;                       // Вычисляемый адрес чтения
	uint8_t  buffer[HANDLER_SIZE];          // Буфер для чтения заголовка и номера файла
	uint16_t NumSectors = 1;                // Число секторов для файла по-умолчанию
	uint16_t i;                             // Счетчик циклов

	for (i = 0; i < HANDLER_SIZE; i++)
		buffer[i] = 0;

	address = FS_SECTOR_SIZE * sector;
	readMemory(address, buffer, HANDLER_SIZE);

	if (*(uint16_t*)(buffer) != FILE_EXIST_HANDLER)
		return 0;

	for (i = 0; i < FS_SECTORS_NUM; i++)
	{
		// Так как файловая система реализована по типу кольцевого буфера,
		// необходимо осуществлять переходы от старшего сектора к нулевому непрерывно
		// Чего и добиваемся этим условием
		sector = (++sector) % FS_SECTORS_NUM;

		// Теперь вычисляем адрес сектора идущим следом за тем, который был передан аргументом
		address = FS_SECTOR_SIZE * sector;
		readMemory(address, buffer, HANDLER_SIZE);
		// Ожидаем находить заголовки продолжения файла
		// Любой другой будет говорить о том, что файл кончился
		if (*(uint16_t*)(buffer) == FILE_CONTINUATION)
			NumSectors++;
		else 
			break;
	}

	return NumSectors;
}




/***************************************************************************************************
	LogFs_getFileProperties - Функция позволяет узнать параметры файла, который был выбран
	функцией "LogFs_findFile": Размер в байтах и порядковый номер в хранилище
***************************************************************************************************/
uint32_t LogFs_getFileProperties(uint8_t cmd)
{
	uint32_t result = 0;

	// Необходимо проверить инициализирована ли структура выбора файла
	// Если нет, значит и файл не выбран, а значит и выводить нечего.
	//if (fileSelector.state != FS_INIT_DONE)
	//	return FS_ERROR;

	// Смотрим, какая информация интересует
	switch (cmd)
	{
		// Спрашивают номер файла
	case FILE_NUMBER:
		result = fileSelector.id;
		break;
		// Спрашивают размер файла файла
	case FILE_SIZE:
		result = fileSelector.size;
		break;

	}
	return result;
}




/***************************************************************************************************
	LogFs_initialize - Функция проверки и инициализации файловой системы. Производит просмотр
	и анализ файл файловой системы, ищет созданые файлы, определяет положения первого
	и последнего файла (по порядковому номеру), определяет количество занимаемых ими секторов,
	производит подсчет свободных секторов, подсчет имеющихся файлов, ищет свободное место
	в котором может быть создан файл. Заполняет управляющую структуру core,
	которая обеспечивает работу файловой системы.
***************************************************************************************************/
LogFs_Status LogFs_initialize(void)
{
	uint32_t   i;                            // Счетчик циклов
	uint32_t   address;                     // Адрес для чтения из памяти
	uint8_t    buffer[HANDLER_SIZE];        // Буфер под читаемый заголовок и номер файла
	uint32_t   lastFileId = 0;              // Номер последнего файла
	uint32_t   firstFileId = 0xFFFFFFFF;    // Номер первого файла

	for (i = 0; i < HANDLER_SIZE; i++)
		buffer[i] = 0;

	// Инициализируем структуру с информацией о файловой системе
	core.files = 0;
	core.freeSectors = FS_SECTORS_NUM;
	core.lastFileBegin = 0;
	core.lastFileSectors = 0;
	core.firstFileBegin = 0;
	core.firstFileSectors = 0;
	core.currentFileSector = 0;
	core.cursorPosition = 0;
	core.state = FS_NOT_INIT;

	// Чтобы узнать состояние файловой системы необходимо из каждого сектора считать первые 4 байта
	for (i = 0; i < FS_SECTORS_NUM; i++)
	{
		// Вычисляем адрес сектора
		address = FS_SECTOR_SIZE * i;
		// Читаем первые 4 байта сектора
		readMemory(address, buffer, HANDLER_SIZE);
		// Проверяем заголовок сектора: содержит ли сектор файл
		if (*(uint16_t*)(buffer) == FILE_EXIST_HANDLER)
		{
			// Инкрементируем счетчик файлов
			core.files++;
			// Декрементируем счетчик свободных секторов
			core.freeSectors--;

			// Определяем наиболее старый файл из имеющихся, для возможной перезаписи
			// Ищем наименьший порядковый номер файла
			if (*(uint16_t*)(buffer + 2) < firstFileId)
			{
				// Запоминаем номер файла
				firstFileId = *(uint16_t*)(buffer + 2);
				// Фиксируем номер сектора, где этот файл лежит
				core.firstFileBegin = i;
			}
			// Определяем последний созданный файл (номер сектора содержащий этот файл)
			// Ищем наибольший порядковый номер файла
			if (*(uint16_t*)(buffer + 2) > lastFileId)
			{
				// Запоминаем номер файла
				lastFileId = *(uint16_t*)(buffer + 2);
				// Фиксируем номер сектора, где этот файл лежит
				core.lastFileBegin = i;
			}
		}
		// Возможно это продолжение файла с предыдущего сектора?
		else if (*(uint16_t*)(buffer) == FILE_CONTINUATION)
		{
			core.freeSectors--;
		}
		// Тогда здесь должно быть пусто
		else if (*(uint16_t*)(buffer) != FREE_SPACE_HANDLER)
			return FS_ERROR;
	}
	// Дополнительно определим размеры в секторах файлов (самого старого и самого свежего)
	core.lastFileSectors = LogFs_getNumberSectorsFile(core.lastFileBegin);
	core.firstFileSectors = LogFs_getNumberSectorsFile(core.firstFileBegin);
	// Информация о диске получена, возвращаем успех
	core.state = FS_INIT_DONE;

	return FS_SUCCESS;
}



/***************************************************************************************************
	LogFs_check - Функция проверки разметки используемого носителя.
***************************************************************************************************/
LogFs_Status LogFs_check(void)
{
	uint32_t i;                     // Счетчик циклов
	uint32_t address;               // Адрес для чтения из памяти
	uint8_t buffer[HANDLER_SIZE];   // Буфер под читаемый заголовок и номер файла

	if (core.state != FS_INIT_DONE && core.state != FS_FILE_OPEN)   // Если файловая система не инициализирована 
		return FS_ERROR;                  // Возвращаем ошибку

	for (i = 0; i < HANDLER_SIZE; i++) 
		buffer[i] = 0;

	// Чтобы узнать состояние файловой системы необходимо из каждого сектора считать первые 4 байта
	for (i = 0; i < FS_SECTORS_NUM; i++)
	{
		address = FS_SECTOR_SIZE * i;                      // Вычисляем адрес сектора
		readMemory(address, buffer, HANDLER_SIZE);         // Читаем первые 4 байта сектора
		                                                   // Проверяем заголовки секторов: содержит ли сектор файл
		if (*(uint16_t*)(buffer) != FILE_EXIST_HANDLER &&  // содержит ли сектор файл
			*(uint16_t*)(buffer) != FILE_CONTINUATION  &&  // продолжение файла
			*(uint16_t*)(buffer) != FREE_SPACE_HANDLER)    // пусто		                                     
			return FS_ERROR;                               // Если нет, то файловая система повреждена
	}
	return FS_SUCCESS;   // Значит разметка носителя не нарушена	
}




/***************************************************************************************************
	LogFs_fullSize - Размер носителя, байт
***************************************************************************************************/
uint64_t LogFs_fullSize(void)
{
	return FS_SECTORS_NUM * (FS_SECTOR_SIZE - HANDLER_SIZE);
}



/***************************************************************************************************
	LogFs_freeBytes - Свободное место на носителе, байт
***************************************************************************************************/
uint64_t LogFs_freeBytes(void)
{
	uint64_t size = 0;
	if (core.state == FS_INIT_DONE || core.state == FS_FILE_OPEN)
	{
		size = ((uint64_t)core.freeSectors * (uint64_t)(FS_SECTOR_SIZE - HANDLER_SIZE));
		if (core.state == FS_FILE_OPEN)
			size += (FS_SECTOR_SIZE - core.cursorPosition);
	}
	return size;
}




/***************************************************************************************************
	LogFs_deleteOldestFile - Функция Удаления самого старого файла в директории. Является
	приватной, ее самостоятельный вызов может привести к ошибке файловой системы.
***************************************************************************************************/
static LogFs_Status LogFs_deleteOldestFile(void)
{
	uint16_t i;                       // Счетчик циклов  
	uint16_t count;                   // Количество секторов занимаемых файлом
	uint32_t address;                 // Вычисляемый адрес чтения/записи
	uint32_t sector;                  // Номер сектора
	uint8_t  buffer[HANDLER_SIZE];    // Буфер для чтения загловка и номера сектора

	for (i = 0; i < HANDLER_SIZE; i++)
		buffer[i] = 0;

	// Определяем сколько секторов занимает файл
	count = LogFs_getNumberSectorsFile(core.firstFileBegin);

	// Стираем сектора, которые занимает самый старый файл
	for (i = 0; i < count; i++)
	{
		// Определяем адреса секторов, в которых он расположен
		address = FS_SECTOR_SIZE * (core.firstFileBegin + i);
		// Так как файловая система реализована по типу кольцевого буфера,
		// необходимо осуществлять переходы от старшего сектора к нулевому непрерывно
		// Чего и добиваемся этим условием
		if (address >= FS_SECTOR_SIZE * FS_SECTORS_NUM) 
			address = address % (FS_SECTOR_SIZE * FS_SECTORS_NUM);
		// Стираем сектор
		eraseSector(address);
	}
	// Обновляем информацию о свободных секторах - теперь их Count штук
	core.freeSectors += count;
	// Декрементируем счетчик файлов
	core.files--;

	// Удалили самый старый файл, теперь необходимо обновить информацию о файловой системе
	// Теперь самым старым файлом в директории будет файл с порядковым номером OldestFile_SectorNum + 1
	// Но необходимо найти начало этого файла
	// Делаем шаг вперед на Count секторов (Count - количество секторов на которых располагался ныне удалённый файл) и смотрим заголовок и номер файла
	sector = (core.firstFileBegin + count) % FS_SECTORS_NUM;
	address = FS_SECTOR_SIZE * sector;
	readMemory(address, buffer, HANDLER_SIZE);
	// Если все в порядке, то здесь должен быть заголовок начала следующего файла
	if (*(uint16_t*)(buffer) != FILE_EXIST_HANDLER)
		return FS_ERROR; // Если нет - файловая система имеет ошибку и завершаем
	
	// Фиксируем сектор нового "старого" файла
	core.firstFileBegin = sector;

	// Теперь необходимо определить сколько секторов занимает новый "старый" файл
	core.firstFileSectors = LogFs_getNumberSectorsFile(core.firstFileBegin);
	// Если попали сюда, значит все хорошо
	return FS_SUCCESS;
}




/***************************************************************************************************
	LogFs_createFile - Функция создания сессии/файла. Ищет свободное место не диске, если
	его нет, удаляет самый старший файл в директории, создает в свободном месте заголовок файла
	и присваивает файлу порядковый номер с момета создания первого файла в ФС.
***************************************************************************************************/
void LogFs_createFile(void)
{
	uint32_t address;                  // Вычисляемый адрес чтения
	uint8_t  buffer[HANDLER_SIZE];     // Буфер для чтения заголовка и номера файла
	uint16_t i;                        // Счетчик циклов

	if (core.state != FS_INIT_DONE)  // Если файловая система не инициализирована запрещаем
		return;                      // что либо делать и выходим и выходим

	for (i = 0; i < HANDLER_SIZE; i++)
		buffer[i] = 0;

	// Чтобы узнать порядковый номер создаваемого файла
	// Воспользуемся информацией о последнем созданном файле
	// К его номеру сделаем икремент - и получим номер нового файла
	address = FS_SECTOR_SIZE * core.lastFileBegin;
	readMemory(address, buffer, HANDLER_SIZE);

	// Если создаётся первый файл в директории, то никакого LastFile не существует 
	// (только в этом случае LastFile будет с заголовком FREE_SPACE_HANDLER).
	// Тогда номер создаеваемого файла точно будет = 0
	if (*(uint16_t*)(buffer) == FREE_SPACE_HANDLER)
		*(uint16_t*)(buffer + 2) = 0;

	// Создаётся не первый файл, в этом случае порядковый номер создаваемого файла
	// будем выбирать как номер последнего созданного + 1
	else
	{
		// А тут к полученному номеру добавляем 1
		*(uint16_t*)(buffer + 2) = *(uint16_t*)(buffer + 2) + 1;
	}

	// А в первые два байта заносим заголовок начала нашего нового файла
	*(uint16_t*)(buffer) = FILE_EXIST_HANDLER;

	// Далее нужно определить место для нового файла
    // Если свободных секторов нет
	if (core.freeSectors == 0)
	{
		// Попав сюда, необходимо освободить сектор(а) с самым старым файлом
		// На его месте будет создан новый файл, поэтому сразу фиксируем сектор старого файла, как текущий рабочий
		core.currentFileSector = core.firstFileBegin;
		// И стираем сектора со старым файлом
		LogFs_deleteOldestFile();
	}
	else // Если свободные сектора есть, то берем сектор сразу за последним
		core.currentFileSector = (core.lastFileBegin + core.lastFileSectors) % FS_SECTORS_NUM;

	// Создаем файл - Размещаем заголовок и номер на секторе диска
	address = FS_SECTOR_SIZE * core.currentFileSector;
	// Записываем заголовок в файл
	writeMemory(address, buffer, HANDLER_SIZE);
	// Смещаем указатель для последующей записи на HANDLER_SIZE байт (в каждом секторе первые HANDLER_SIZE байт - резерв файловой системы)
	core.cursorPosition = HANDLER_SIZE;
	// Раз заняли один сектор новым файлом, то нужно декрементировать счетчик свободных секторов
	core.freeSectors--;
	// Файл создан, нужно обновить счетчик файлов и состояние
	core.files++;
	core.state = FS_FILE_OPEN;
	// После создания нового файла, он становится последним в списке
	core.lastFileBegin = core.currentFileSector;
	core.lastFileSectors = 1;
}



/***************************************************************************************************
	LogFs_writeToCurrentFile - Функция записи информации в файл
***************************************************************************************************/
void LogFs_writeToCurrentFile(uint8_t* buffer, uint32_t size)
{
	uint32_t i;                     // Счетчик циклов
	uint32_t address;               // Вычисляемый адрес для чтения
	uint8_t  _buffer[HANDLER_SIZE]; // Буфер для чтения заголовка и номера файла
	uint32_t adr;                   // Вычисляемый адрес для реализации перехода между секторами

	if (core.state != FS_FILE_OPEN)  // Проверим открыт ли файл, и если нет, то
		return;                      // ничего не делаем

	for (i = 0; i < HANDLER_SIZE; i++)
		_buffer[i] = 0;

	// Определяем адрес для начала записи по выделенному сектору и смещению от его начала "CurrentWritePosition"
	address = FS_SECTOR_SIZE * core.currentFileSector + core.cursorPosition;

	// Проверяем хватит ли нам места в текущем секторе
	if ((core.cursorPosition + size) >= FS_SECTOR_SIZE)
	{
		// Не хватает свободного места, необходимо освободить
		uint32_t currentSectorFreeSpace = (FS_SECTOR_SIZE - core.cursorPosition);
		uint16_t needFreeSector = (0.5 + ((double)(size - currentSectorFreeSpace) / (FS_SECTOR_SIZE - HANDLER_SIZE)));

		// Посмотрим имеются ли свободные сектора
		while (core.freeSectors < needFreeSector && core.files > 1)
			// Нет, нужно освободить место, удалив самый старый из имеющихся файлов, кроме случаев, когда он единственный
			LogFs_deleteOldestFile();
	}

	// Будем писать побайтово, так как нужен контроль над переходом на новый сектор
	// Там может быть, например, не пусто 
	for (i = 0; i < size; i++)
	{
		/* Здесь ограничение на запись: если файл единственный удалять больше нечего, 
		 * и место закончилось, то просто брокируем запись и выходим */
		if (core.files <= 1 && LogFs_freeBytes() <= 0) 
			return;

		// Определяем адрес места записи
		address = FS_SECTOR_SIZE * core.currentFileSector + core.cursorPosition;

		// Условие для контроля перехода между секторами
		// Определяем границу перехода по позиции в секторе, если она равна размеру сектора, это и есть граница
		if (core.cursorPosition == FS_SECTOR_SIZE)
		{
			/* Попали на новый сектор, необходимо объявить о продолжении файла, создав в следующем секторе 
			 * соответствующий заголовок и дублировать номер файла, для чего возвращаемся к началу текущего сектора,
			 * чтобы клонировать его разметку */
			address = FS_SECTOR_SIZE * core.currentFileSector;   // Узнаем номер текущего файла в каталоге
			readMemory(address, _buffer, HANDLER_SIZE);         // Читаем первые HANDLER_SIZE байт разметки
			*(uint16_t*)(_buffer) = FILE_CONTINUATION;          // Информацию получили, теперь подменим заголовок 
			                                                    // на заголовок продолжения файла, номер остаётся таким же
			// Если сектор последний - нужно перейти на первый (кольцевой буфер)
			core.currentFileSector = (++core.currentFileSector) % FS_SECTORS_NUM;
			// Так же наш самый новый файл (то есть текущий), стал занимать на один сектор больше
			core.lastFileSectors = (++core.lastFileSectors) % FS_SECTORS_NUM;

			address = FS_SECTOR_SIZE * core.currentFileSector;  // Вычисляем адрес для записи (начало нового сектора)
			writeMemory(address, _buffer, HANDLER_SIZE);       // Размечаем этот сектор как продолжение нашего файла
			core.freeSectors--;                                // Декрементируем кол-во свободных секторов
			core.cursorPosition = HANDLER_SIZE;                // Задаем смещение на размер заголовка и номера от начала нового сектора
			//Вычисляем адрес для записи
			address = FS_SECTOR_SIZE * core.currentFileSector + core.cursorPosition;
		    // Теперь все готово к записи
		}

		// Пишем в файл, и делаем инкремент смещения от начала сектора
		if (buffer[i] != 0xFF)
		{
			writeMemory(address, &buffer[i], 1);
			core.cursorPosition++;
		}
	}
}



/***************************************************************************************************
	LogFs_findFile - Функция поиска файлов в директории
***************************************************************************************************/
LogFs_Status LogFs_findFile(uint8_t cmd)
{
	uint32_t           address;            // Вычисляемый адрес для чтения                     
	uint8_t            buffer[2];          // Буфер для чтения заголовка и номера файла
	uint32_t           i;                  // Счеттчик циклов
	static uint32_t    FileCount = 0;      // Количество просмотренных файлов

	// Если файлы отсутсвуют или система не инициализированна, то нечего искать
	if (core.files <= 0 || (core.state != FS_INIT_DONE && core.state != FS_FILE_OPEN))
		return FS_ERROR;

	// Посмотрим, что за команда
	// Если структура не была проинициализирована и вдруг приходит команда NEXT_FILE (Которая должна приходить только после FIRST_FILE)
	// Это ошибка
	if (cmd == NEXT_FILE && fileSelector.state != FS_INIT_DONE)
		return FS_ERROR;

	// Команда на запрос информации о самом старом файле в директории, равносильно команде на инициализацию структуры (отсчетной точкой будет старый файл)
	else if (cmd == FIRST_FILE)
	{
		// Сбрасываем и инициализируем структуру работы с файлами
		fileSelector.size = 0;
		fileSelector.id = 0;
		fileSelector.sectors = core.firstFileSectors;
		fileSelector.begin = core.firstFileBegin;

		// Сбрасываем счетчик просмотренных файлов
		FileCount = 0;
	}
	// Команда на запрос информации о самом новом файле в директории
	else if (cmd == LAST_FILE)
	{
		fileSelector.size = 0;
		fileSelector.id = 0;
		fileSelector.sectors = core.lastFileSectors;
		fileSelector.begin = core.lastFileBegin;

		// Сбрасываем счетчик просмотренных файлов
		FileCount = core.files - 1;
	}
	// Переходим к следующему файлу, если структура была инициализирована (точка отсчета есть)
	else if (cmd == NEXT_FILE && fileSelector.state == FS_INIT_DONE)
	{
		fileSelector.size = 0;
		fileSelector.id = 0;

		// Переходим к началу следующего файла, отталкиваясь от сектора предыдущего и количества секторов которые он занимал 
		fileSelector.begin = (fileSelector.begin + fileSelector.sectors) % FS_SECTORS_NUM;

		// Теперь необходимо определить сколько секторов занимает этот файл
		for (i = 1; i < FS_SECTORS_NUM; i++)
		{
			address = FS_SECTOR_SIZE * (fileSelector.begin + i);
			// Контролируем переходы кольцевого буфера (чтобы избежать переполнения и обращения по несуществующему адресу)
			address = address % (FS_SECTORS_NUM * FS_SECTOR_SIZE);
			// Будем читать заголовки секторов после StartSector пока не найдем FILE_EXIST_HANDLER - признак начала следующего файла
			readMemory(address, buffer, 2);
			if (*(uint16_t*)(buffer) == FILE_EXIST_HANDLER || *(uint16_t*)(buffer) == 0xFFFF)
				break;
		}
		// Фиксируем число таких секторов
		fileSelector.sectors = i;
	}
	// Иначе команда неопознана - возвращаем ошибку
	else
		return FS_ERROR;

	// Получаем адрес сектора расположения файла
	address = FS_SECTOR_SIZE * fileSelector.begin;

	// Проверим присутсвует ли по этому адресу заголовок начала файла
	readMemory(address, buffer, 2);
	if (*(uint16_t*)(buffer) == FILE_EXIST_HANDLER)
		fileSelector.state = FS_INIT_DONE;
	else 
		return FS_ERROR; // Заголовка нет, файловая система содержит ошибку

	// Узнаем порядковый номер этого файла в директории
	address += 2;
	readMemory(address, buffer, 2);
	fileSelector.id = *(uint16_t*)(buffer);

	// Если файл содержится на нескольких секторах, сразу переходим в последний
	if (fileSelector.sectors > 1)
	{
		// Определяем адрес этого сектора
		address = FS_SECTOR_SIZE * (fileSelector.begin + fileSelector.sectors - 1);
		// Контролируем переходы кольцевого буфера (чтобы избежать переполнения и обращения по несуществующему адресу)
		address = address % (FS_SECTORS_NUM * FS_SECTOR_SIZE);
		// А счетчик байт файла инкрементируем на (FS_SECTOR_SIZE - 4) * (Количество занятых файлом секторов - 1)
		fileSelector.size = (FS_SECTOR_SIZE - 4) * (fileSelector.sectors - 1);
		// Смещаем адрес на 4 заголовочных байта
		address += 4;
	}
	// Если же файл содержится только в текущем секторе смещаем адрес еще на 2 байта (от номера файла; на первый байт данных)
	else
		address += 2;

	// Дальше начинаем искать конец файла
	for (i = 0; i < FS_SECTOR_SIZE - 4; i++)
	{
		// Будем считывать байт за байтом из этого сектора и смотреть не упёрлись ли мы в конец (0xFF - форматированная ячейка)
		readMemory(address, &buffer[0], 1);
		// Если конец файла, то выходим
		if (*(uint8_t*)(buffer) == 0xFF)
			break;
		// Если попали сюда, то полученный байт не признак конца и нужно инкрементировать счетчик байт и адрес
		address++;
		fileSelector.size++;
	}
	// Инкрементируем счетчик просмотренных файлов, так как если мы дошли сюда, значит файл просмотрен
	FileCount++;
	// Проверяем все ли файлы в хранилище были просмотрены
	if (core.files <= FileCount)
	{
		fileSelector.state = FS_INIT_NO;
		return FS_ALL_FILES_SCROLLS;
	}

	return FS_NOT_OVER;
}



/***************************************************************************************************
	LogFs_findFileByNum - Функция осуществляет поиск файла по номеру.
***************************************************************************************************/
LogFs_Status LogFs_findFileByNum(uint16_t id)
{
	uint16_t files = 0;    // Количество файлов в хранилище
	uint16_t minId;    // Минимальный порядковый номер среди файлов 
	uint16_t maxId;    // Максимальный порядковый номер среди файлов
	uint16_t i;            // Счетчик циклов


	// Если файлы отсутсвуют или система не инициализированна, то нечего искать
	if (core.files <= 0 || (core.state != FS_INIT_DONE && core.state != FS_FILE_OPEN))
		return FS_ERROR;

	// Проверим существует ли такой номер
	// Посмотрим порядковый номер самого свежего файла (номер должен быть самым большим)
	LogFs_findFile(LAST_FILE);
	maxId = LogFs_getFileProperties(FILE_NUMBER);

	// Посмотрим порядковый номер самого старого файла (номер должен быть самым маленьким)
	LogFs_findFile(FIRST_FILE);
	minId = LogFs_getFileProperties(FILE_NUMBER);

	// Номер запрашиваемого файла должен принадлжеать данному диапазону, иначе ошибка - файл не найден
	if (id > maxId || id < minId)
		return FS_ERROR;

	// Получим число файлов в хранилище
	files = LogFs_getFileNumber();

	for (i = 0; i < files; i++)
	{
		if (i == 0)
			LogFs_findFile(FIRST_FILE);
		else
			LogFs_findFile(NEXT_FILE);
		// Сверяем номер файла. Если совпадает файл найден можно выходить
		if (LogFs_getFileProperties(FILE_NUMBER) == id)
			return FS_SUCCESS;
	}
	// Если дошли сюда, значит файл не найден - ошибка
	return FS_ERROR;
}



/***************************************************************************************************
	LogFs_readFile - Функция чтения информации из файлов. Должна запускаться только после функции
	LogFs_findFile(), поскольку эта функция и позволяет нам определить какой файл будем
	читать. То, какой файл будем читать содержится в структуре fileSelector.
***************************************************************************************************/
LogFs_Status LogFs_readFile(uint8_t* buffer, uint32_t position, uint32_t size)
{
	uint32_t address;     // Адрес чтения 
	uint32_t i;           // Счетчик циклов
	uint32_t sector;      // Номер сектора от начала файла

	if (core.state == FS_NOT_INIT || core.files <= 0)
		return FS_ERROR;

	// Проверим корректность параметров, и запретим чтение за пределами файла
	if (position + size > fileSelector.size)
		return FS_ERROR;


	// Определяем к какому сектору файла относится первый читаемый байт
	sector = position / (FS_SECTOR_SIZE - HANDLER_SIZE);

	// Получаем текущий адрес ячейки для чтения
	// Сначала адрес нужного сектора с контролем переходов
	address = (FS_SECTOR_SIZE * (fileSelector.begin + sector)) % (FS_SECTOR_SIZE * FS_SECTORS_NUM);
	// Затем задаем необходимое смещение от начала сектора
	address += 4 + (position % (FS_SECTOR_SIZE - HANDLER_SIZE));

	// Начинаем побайтово читать файл
	for (i = 0; i < size; i++)
	{
		// Читаем байт
		readMemory(address, &buffer[i], 1);
		// Инкрементируем адрес с контролем перехода кольцевого буфера
		address = (address + 1) % (FS_SECTOR_SIZE * FS_SECTORS_NUM);
		// Проверим, вдруг адрес указывает на первые 4 байта заголовка сектора
		if (address % FS_SECTOR_SIZE == 0)
		{
			// Они нам не нужны, поэтому сразу перепрыгиваем на 4 байта вперед
			address += 4;
		}
	}
	return FS_SUCCESS;
}

