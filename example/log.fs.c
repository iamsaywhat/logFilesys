/****************************************************************************************************************************

	log.fs - Модуль облегченной "файловой системы" для записи логов в "черном ящике".

*****************************************************************************************************************************/

#include "log.fs.h"
#include "log.fs.platformdepend.h"


/*----------------------------------- Приватная часть модуля---------------------------------------------------------------------*/


/************************************************************
	Управляющая структура для работы файловой системы
************************************************************/
struct {
	uint16_t files;                 // Количество файлов на диске
	uint16_t freeSectors;           // Количество свободных секторов
	uint16_t lastFileBegin;         // Сектор с последним созданным файлом
	uint16_t lastFileSectors;       // Количество секторов, которые занимает последний созданный файл
	uint16_t firstFileBegin;        // Самый старый файл на диске
	uint16_t firstFileSectors;      // Количество секторов, которые занимает самый старый созданный файл
	uint16_t currentFileSector;     // Свободный сектор, где можно создать новый файл
	uint32_t cursorPosition;        // Позиция в файле для записи
	LogFs_Status state;
} core = { 0,FS_SECTORS_NUM,0,0,0,0,0,0,FS_NOT_INIT };

/************************************************************
	Структура для обеспечения доступа к файлам
************************************************************/
struct {
	uint32_t id;                     // Порядковый номер файла
	uint32_t size;                   // Размер файла в байтах
	uint16_t sectors;                // Число секторов на которых размещен файл
	uint16_t begin;                  // Стартовый сектор файла
	LogFs_Status state;              // Статус селектора
} fileSelector = { 0,0,0,0,FS_NOT_INIT };


/***************************************************************************************************
	LogFs_deleteOldestFile - Функция Удаления самого старого файла в директории. Является
	приватной, ее самостоятельный вызов может привести к ошибке файловой системы.

	Примечание:  В случае полной заполненности памяти, при создании файла - произойдет вызов
	этой функции. Она удалит самый старый из имеющихся файлов и произведет очистку секторов,
	которые он занимал.

	Возвращает:
				FS_SUCCESS  - Файл был удачно удален из директории
				FS_ERROR - Неизвестное форматирование (файловая система имеет внутреннюю ошибку
***************************************************************************************************/
static LogFs_Status LogFs_deleteOldestFile(void);


/***************************************************************************************************
	LogFs_getNumberSectorsFile - Узнать количество секторов которые занимает файл c началом
	в секторе с номером Sector;
	Параметры:
				Sector - Номер сектора в котором начинается файл (от 0 до FS_SECTORS_NUM - 1)
	Возвращает:
				Количество секторов которые занимает файл
***************************************************************************************************/
static uint16_t LogFs_getNumberSectorsFile(uint16_t Sector);

/***************************************************************************************************
	LogFs_getFileIdAtSector - Узнать ID файла, который находится в секторе sector;
	в секторе с номером Sector

	Параметры:
				Sector - Номер сектора в котором находится файл (от 0 до FS_SECTORS_NUM - 1)
	Возвращает:
				id файла
***************************************************************************************************/
static uint16_t LogFs_getFileIdAtSector(uint16_t sector);

/*------------------------------------------Публичная часть модуля-------------------------------------------------------------*/



/***************************************************************************************************
	LogFs_format - Форматирование накопителя (полная очистка с потерей всех данных)
***************************************************************************************************/
void LogFs_format(void)
{
	eraseChip();
}


/***************************************************************************************************
	LogFs_getFileNumber - Получение информации о числе имеющихся файлов в директории
***************************************************************************************************/
uint16_t LogFs_getFileNumber(void)
{
	// Если файловая система не инициализирована, то выходим
	if (core.state != FS_INIT_DONE && core.state != FS_FILE_OPEN)
		return 0;
	else
		return core.files;
}



/***************************************************************************************************
	LogFs_getLastFileID - Узнать порядковый номер последнего созданного файла
***************************************************************************************************/
uint16_t LogFs_getLastFileID(void)
{
	uint32_t address;               // Вычисляемый адрес для чтения
	uint8_t  buffer[HANDLER_SIZE];  // Буфер для чтения заголовка и номера файла
	uint16_t i;                     // Счетчик циклов

	// Если файловая система не инициализирована, то выходим
	if (core.state != FS_INIT_DONE && core.state != FS_FILE_OPEN)
		return 0;

	for (i = 0; i < HANDLER_SIZE; i++) 
		buffer[i] = 0;

	// Определяем стартовый адрес расположения последнего созданного файла
	address = FS_SECTOR_SIZE * core.lastFileBegin;
	// Читаем залоговок и номер файла
	readMemory(address, buffer, HANDLER_SIZE);

	// Возвращаем порядкой номер файла
	return *(uint16_t*)(buffer + 2);
}

/***************************************************************************************************
	LogFs_getFileIdAtSector - Узнать ID файла, который находится в секторе sector;
	в секторе с номером Sector
***************************************************************************************************/
static uint16_t LogFs_getFileIdAtSector(uint16_t sector)
{
	uint32_t address;               // Вычисляемый адрес для чтения
	uint8_t  buffer[HANDLER_SIZE];  // Буфер для чтения заголовка и номера файла
	uint16_t i;                     // Счетчик циклов

	// Если файловая система не инициализирована, то выходим
	if (core.state != FS_INIT_DONE && core.state != FS_FILE_OPEN)
		return 0;

	for (i = 0; i < HANDLER_SIZE; i++)
		buffer[i] = 0;

	// Определяем стартовый адрес расположения последнего созданного файла
	address = FS_SECTOR_SIZE * sector;
	// Читаем залоговок и номер файла
	readMemory(address, buffer, HANDLER_SIZE);

	// Возвращаем порядкой номер файла
	return *(uint16_t*)(buffer + 2);
}

/***************************************************************************************************
	LogFs_getNumberSectorsFile - Количество секторов которые занимает файл c началом
	в секторе с номером Sector
***************************************************************************************************/
static uint16_t LogFs_getNumberSectorsFile(uint16_t sector)
{
	uint32_t address;                       // Вычисляемый адрес чтения
	uint8_t  buffer[HANDLER_SIZE];          // Буфер для чтения заголовка и номера файла
	uint16_t NumSectors = 1;                // Число секторов для файла по-умолчанию
	uint16_t i;                             // Счетчик циклов

	for (i = 0; i < HANDLER_SIZE; i++)
		buffer[i] = 0;

	address = FS_SECTOR_SIZE * sector;
	readMemory(address, buffer, HANDLER_SIZE);

	if (*(uint16_t*)(buffer) != FILE_EXIST_HANDLER)
		return 0;

	for (i = 0; i < FS_SECTORS_NUM; i++)
	{
		// Так как файловая система реализована по типу кольцевого буфера,
		// необходимо осуществлять переходы от старшего сектора к нулевому непрерывно
		// Чего и добиваемся этим условием
		sector = (++sector) % FS_SECTORS_NUM;

		// Теперь вычисляем адрес сектора идущим следом за тем, который был передан аргументом
		address = FS_SECTOR_SIZE * sector;
		readMemory(address, buffer, HANDLER_SIZE);
		// Ожидаем находить заголовки продолжения файла
		// Любой другой будет говорить о том, что файл кончился
		if (*(uint16_t*)(buffer) == FILE_CONTINUATION)
			NumSectors++;
		else 
			break;
	}

	return NumSectors;
}


/***************************************************************************************************
	LogFs_getFileProperties - Функция позволяет узнать размер файла, который был выбран
	функцией "LogFs_findFile"
	Возвращает:
				Размер в байтах файла
***************************************************************************************************/
uint32_t LogFs_getFileSize(void)
{
	if (fileSelector.state == FS_INIT_DONE)
		return fileSelector.size;
	else
		return 0;
}


/***************************************************************************************************
	LogFs_getFileID - Функция позволяет узнать ID файла, который был выбран
	функцией "LogFs_findFile"
	Возвращает:
				Порядковый номер файла (ID) в хранилище (FILE_NUM);
***************************************************************************************************/
uint32_t LogFs_getFileID(void)
{
	if (fileSelector.state == FS_INIT_DONE)
		return fileSelector.id;
	else
		return 0;
}

/***************************************************************************************************
	LogFs_initialize - Функция проверки и инициализации файловой системы. Производит просмотр
	и анализ файл файловой системы, ищет созданые файлы, определяет положения первого
	и последнего файла (по порядковому номеру), определяет количество занимаемых ими секторов,
	производит подсчет свободных секторов, подсчет имеющихся файлов, ищет свободное место
	в котором может быть создан файл. Заполняет управляющую структуру core,
	которая обеспечивает работу файловой системы.
***************************************************************************************************/
LogFs_Status LogFs_initialize(void)
{
	uint32_t   i;                            // Счетчик циклов
	uint32_t   address;                     // Адрес для чтения из памяти
	uint8_t    buffer[HANDLER_SIZE];        // Буфер под читаемый заголовок и номер файла
	uint32_t   lastFileId = 0;              // Номер последнего файла
	uint32_t   firstFileId = 0xFFFFFFFF;    // Номер первого файла

	for (i = 0; i < HANDLER_SIZE; i++)
		buffer[i] = 0;

	// Инициализируем структуру с информацией о файловой системе
	core.files = 0;
	core.freeSectors = FS_SECTORS_NUM;
	core.lastFileBegin = 0;
	core.lastFileSectors = 0;
	core.firstFileBegin = 0;
	core.firstFileSectors = 0;
	core.currentFileSector = 0;
	core.cursorPosition = 0;
	core.state = FS_NOT_INIT;

	// Чтобы узнать состояние файловой системы необходимо из каждого сектора считать первые 4 байта
	for (i = 0; i < FS_SECTORS_NUM; i++)
	{
		// Вычисляем адрес сектора
		address = FS_SECTOR_SIZE * i;
		// Читаем первые 4 байта сектора
		readMemory(address, buffer, HANDLER_SIZE);
		// Проверяем заголовок сектора: содержит ли сектор файл
		if (*(uint16_t*)(buffer) == FILE_EXIST_HANDLER)
		{
			// Инкрементируем счетчик файлов
			core.files++;
			// Декрементируем счетчик свободных секторов
			core.freeSectors--;

			// Определяем наиболее старый файл из имеющихся, для возможной перезаписи
			// Ищем наименьший порядковый номер файла
			if (*(uint16_t*)(buffer + 2) < firstFileId)
			{
				// Запоминаем номер файла
				firstFileId = *(uint16_t*)(buffer + 2);
				// Фиксируем номер сектора, где этот файл лежит
				core.firstFileBegin = i;
			}
			// Определяем последний созданный файл (номер сектора содержащий этот файл)
			// Ищем наибольший порядковый номер файла
			if (*(uint16_t*)(buffer + 2) > lastFileId)
			{
				// Запоминаем номер файла
				lastFileId = *(uint16_t*)(buffer + 2);
				// Фиксируем номер сектора, где этот файл лежит
				core.lastFileBegin = i;
			}
		}
		// Возможно это продолжение файла с предыдущего сектора?
		else if (*(uint16_t*)(buffer) == FILE_CONTINUATION)
		{
			core.freeSectors--;
		}
		// Тогда здесь должно быть пусто
		else if (*(uint16_t*)(buffer) != FREE_SPACE_HANDLER)
			return FS_ERROR;
	}
	// Дополнительно определим размеры в секторах файлов (самого старого и самого свежего)
	core.lastFileSectors = LogFs_getNumberSectorsFile(core.lastFileBegin);
	core.firstFileSectors = LogFs_getNumberSectorsFile(core.firstFileBegin);
	// Информация о диске получена, возвращаем успех
	core.state = FS_INIT_DONE;

	return FS_SUCCESS;
}


/***************************************************************************************************
	LogFs_check - Функция проверки разметки используемого носителя.
***************************************************************************************************/
LogFs_Status LogFs_check(void)
{
	uint32_t i;                     // Счетчик циклов
	uint32_t address;               // Адрес для чтения из памяти
	uint8_t buffer[HANDLER_SIZE];   // Буфер под читаемый заголовок и номер файла

	if (core.state != FS_INIT_DONE && core.state != FS_FILE_OPEN)   // Если файловая система не инициализирована 
		return FS_ERROR;                  // Возвращаем ошибку

	for (i = 0; i < HANDLER_SIZE; i++) 
		buffer[i] = 0;

	// Чтобы узнать состояние файловой системы необходимо из каждого сектора считать первые 4 байта
	for (i = 0; i < FS_SECTORS_NUM; i++)
	{
		address = FS_SECTOR_SIZE * i;                      // Вычисляем адрес сектора
		readMemory(address, buffer, HANDLER_SIZE);         // Читаем первые 4 байта сектора
		                                                   // Проверяем заголовки секторов: содержит ли сектор файл
		if (*(uint16_t*)(buffer) != FILE_EXIST_HANDLER &&  // содержит ли сектор файл
			*(uint16_t*)(buffer) != FILE_CONTINUATION  &&  // продолжение файла
			*(uint16_t*)(buffer) != FREE_SPACE_HANDLER)    // пусто		                                     
			return FS_ERROR;                               // Если нет, то файловая система повреждена
	}
	return FS_SUCCESS;   // Значит разметка носителя не нарушена	
}


/***************************************************************************************************
	LogFs_totalSize - Размер носителя, байт
***************************************************************************************************/
uint64_t LogFs_totalSize(void)
{
	return FS_SECTORS_NUM * (FS_SECTOR_SIZE - HANDLER_SIZE);
}


/***************************************************************************************************
	LogFs_freeSpace - Свободное место на носителе, байт
***************************************************************************************************/
uint64_t LogFs_freeSpace(void)
{
	uint64_t size = 0;
	if (core.state == FS_INIT_DONE || core.state == FS_FILE_OPEN)
	{
		size = ((uint64_t)core.freeSectors * (uint64_t)(FS_SECTOR_SIZE - HANDLER_SIZE));
		if (core.state == FS_FILE_OPEN)
			size += (FS_SECTOR_SIZE - core.cursorPosition);
	}
	return size;
}

/***************************************************************************************************
	LogFs_deleteOldestFile - Функция Удаления самого старого файла в директории. Является
	приватной, ее самостоятельный вызов может привести к ошибке файловой системы.
***************************************************************************************************/
static LogFs_Status LogFs_deleteOldestFile(void)
{
	uint16_t i;                       // Счетчик циклов  
	uint16_t count;                   // Количество секторов занимаемых файлом
	uint32_t address;                 // Вычисляемый адрес чтения/записи
	uint32_t sector;                  // Номер сектора
	uint8_t  buffer[HANDLER_SIZE];    // Буфер для чтения загловка и номера сектора

	for (i = 0; i < HANDLER_SIZE; i++)
		buffer[i] = 0;

	// Если fileSelector указывает на файл, который мы удаляем, сбрасываем его инициализацию
	if ((fileSelector.state == FS_INIT_DONE) && (fileSelector.id == LogFs_getFileIdAtSector(core.firstFileBegin)))
		fileSelector.state = FS_NOT_INIT;

	// Определяем сколько секторов занимает файл
	count = LogFs_getNumberSectorsFile(core.firstFileBegin);

	// Стираем сектора, которые занимает самый старый файл
	for (i = 0; i < count; i++)
	{
		// Определяем адреса секторов, в которых он расположен
		address = FS_SECTOR_SIZE * (core.firstFileBegin + i);
		// Так как файловая система реализована по типу кольцевого буфера,
		// необходимо осуществлять переходы от старшего сектора к нулевому непрерывно
		// Чего и добиваемся этим условием
		if (address >= FS_SECTOR_SIZE * FS_SECTORS_NUM) 
			address = address % (FS_SECTOR_SIZE * FS_SECTORS_NUM);
		// Стираем сектор
		eraseSector(address);
	}
	// Обновляем информацию о свободных секторах - теперь их Count штук
	core.freeSectors += count;
	// Декрементируем счетчик файлов
	core.files--;

	// Удалили самый старый файл, теперь необходимо обновить информацию о файловой системе
	// Теперь самым старым файлом в директории будет файл с порядковым номером OldestFile_SectorNum + 1
	// Но необходимо найти начало этого файла
	// Делаем шаг вперед на Count секторов (Count - количество секторов на которых располагался ныне удалённый файл) и смотрим заголовок и номер файла
	sector = (core.firstFileBegin + count) % FS_SECTORS_NUM;
	address = FS_SECTOR_SIZE * sector;
	readMemory(address, buffer, HANDLER_SIZE);
	// Если все в порядке, то здесь должен быть заголовок начала следующего файла
	if (*(uint16_t*)(buffer) != FILE_EXIST_HANDLER)
		return FS_ERROR; // Если нет - файловая система имеет ошибку и завершаем
	
	// Фиксируем сектор нового "старого" файла
	core.firstFileBegin = sector;

	// Теперь необходимо определить сколько секторов занимает новый "старый" файл
	core.firstFileSectors = LogFs_getNumberSectorsFile(core.firstFileBegin);
	// Если попали сюда, значит все хорошо
	return FS_SUCCESS;
}

/***************************************************************************************************
	LogFs_create - Функция создания сессии/файла. Ищет свободное место не диске, если
	его нет, удаляет самый старший файл в директории, создает в свободном месте заголовок файла
	и присваивает файлу порядковый номер с момета создания первого файла в ФС.
***************************************************************************************************/
void LogFs_create(void)
{
	uint32_t address;                  // Вычисляемый адрес чтения
	uint8_t  buffer[HANDLER_SIZE];     // Буфер для чтения заголовка и номера файла
	uint16_t i;                        // Счетчик циклов

	if (core.state != FS_INIT_DONE)  // Если файловая система не инициализирована запрещаем
		return;                      // что либо делать и выходим и выходим

	for (i = 0; i < HANDLER_SIZE; i++)
		buffer[i] = 0;

	// Чтобы узнать порядковый номер создаваемого файла
	// Воспользуемся информацией о последнем созданном файле
	// К его номеру сделаем икремент - и получим номер нового файла
	address = FS_SECTOR_SIZE * core.lastFileBegin;
	readMemory(address, buffer, HANDLER_SIZE);

	// Если создаётся первый файл в директории, то никакого LastFile не существует 
	// (только в этом случае LastFile будет с заголовком FREE_SPACE_HANDLER).
	// Тогда номер создаеваемого файла точно будет = 0
	if (*(uint16_t*)(buffer) == FREE_SPACE_HANDLER)
		*(uint16_t*)(buffer + 2) = 0;

	// Создаётся не первый файл, в этом случае порядковый номер создаваемого файла
	// будем выбирать как номер последнего созданного + 1
	else
	{
		// А тут к полученному номеру добавляем 1
		*(uint16_t*)(buffer + 2) = *(uint16_t*)(buffer + 2) + 1;
	}

	// А в первые два байта заносим заголовок начала нашего нового файла
	*(uint16_t*)(buffer) = FILE_EXIST_HANDLER;

	// Далее нужно определить место для нового файла
    // Если свободных секторов нет
	if (core.freeSectors == 0)
	{
		// Попав сюда, необходимо освободить сектор(а) с самым старым файлом
		// На его месте будет создан новый файл, поэтому сразу фиксируем сектор старого файла, как текущий рабочий
		core.currentFileSector = core.firstFileBegin;
		// И стираем сектора со старым файлом
		LogFs_deleteOldestFile();
	}
	else // Если свободные сектора есть, то берем сектор сразу за последним
		core.currentFileSector = (core.lastFileBegin + core.lastFileSectors) % FS_SECTORS_NUM;

	// Создаем файл - Размещаем заголовок и номер на секторе диска
	address = FS_SECTOR_SIZE * core.currentFileSector;
	// Записываем заголовок в файл
	writeMemory(address, buffer, HANDLER_SIZE);
	// Смещаем указатель для последующей записи на HANDLER_SIZE байт (в каждом секторе первые HANDLER_SIZE байт - резерв файловой системы)
	core.cursorPosition = HANDLER_SIZE;
	// Раз заняли один сектор новым файлом, то нужно декрементировать счетчик свободных секторов
	core.freeSectors--;
	// После создания нового файла, он становится последним в списке
	core.lastFileBegin = core.currentFileSector;
	core.lastFileSectors = 1;
	// Файл создан, нужно обновить счетчик файлов и состояние
	core.files++;
	core.state = FS_FILE_OPEN;
}


/***************************************************************************************************
	LogFs_write - Функция записи информации в файл
***************************************************************************************************/
void LogFs_write(uint8_t* buffer, uint32_t size)
{
	uint32_t i;                     // Счетчик циклов
	uint32_t address;               // Вычисляемый адрес для чтения
	uint8_t  _buffer[HANDLER_SIZE]; // Буфер для чтения заголовка и номера файла

	if (core.state != FS_FILE_OPEN)  // Проверим открыт ли файл, и если нет, то
		return;                      // ничего не делаем

	for (i = 0; i < HANDLER_SIZE; i++)
		_buffer[i] = 0;

	// Определяем адрес для начала записи по выделенному сектору и смещению от его начала "CurrentWritePosition"
	address = FS_SECTOR_SIZE * core.currentFileSector + core.cursorPosition;

	// Проверяем хватит ли нам места в текущем секторе
	if ((core.cursorPosition + size) >= FS_SECTOR_SIZE)
	{
		// Не хватает свободного места, необходимо освободить
		uint32_t currentSectorFreeSpace = (FS_SECTOR_SIZE - core.cursorPosition);
		uint16_t needFreeSector = (uint16_t)(0.5 + ((double)(size - currentSectorFreeSpace) / (((uint64_t)FS_SECTOR_SIZE) - HANDLER_SIZE)));

		// Посмотрим имеются ли свободные сектора
		while (core.freeSectors < needFreeSector && core.files > 1)
			// Нет, нужно освободить место, удалив самый старый из имеющихся файлов, кроме случаев, когда он единственный
			LogFs_deleteOldestFile();
	}

	// Будем писать побайтово, так как нужен контроль над переходом на новый сектор
	// Там может быть, например, не пусто 
	for (i = 0; i < size; i++)
	{
		/* Здесь ограничение на запись: если файл единственный удалять больше нечего, 
		 * и место закончилось, то просто брокируем запись и выходим */
		if (core.files <= 1 && LogFs_freeSpace() <= 0) 
			return;

		// Определяем адрес места записи
		address = FS_SECTOR_SIZE * core.currentFileSector + core.cursorPosition;

		// Условие для контроля перехода между секторами
		// Определяем границу перехода по позиции в секторе, если она равна размеру сектора, это и есть граница
		if (core.cursorPosition == FS_SECTOR_SIZE)
		{
			/* Попали на новый сектор, необходимо объявить о продолжении файла, создав в следующем секторе 
			 * соответствующий заголовок и дублировать номер файла, для чего возвращаемся к началу текущего сектора,
			 * чтобы клонировать его разметку */
			address = FS_SECTOR_SIZE * core.currentFileSector;   // Узнаем номер текущего файла в каталоге
			readMemory(address, _buffer, HANDLER_SIZE);         // Читаем первые HANDLER_SIZE байт разметки
			*(uint16_t*)(_buffer) = FILE_CONTINUATION;          // Информацию получили, теперь подменим заголовок 
			                                                    // на заголовок продолжения файла, номер остаётся таким же
			// Если сектор последний - нужно перейти на первый (кольцевой буфер)
			core.currentFileSector = (++core.currentFileSector) % FS_SECTORS_NUM;
			// Так же наш самый новый файл (то есть текущий), стал занимать на один сектор больше
			core.lastFileSectors = (++core.lastFileSectors) % FS_SECTORS_NUM;

			address = FS_SECTOR_SIZE * core.currentFileSector;  // Вычисляем адрес для записи (начало нового сектора)
			writeMemory(address, _buffer, HANDLER_SIZE);       // Размечаем этот сектор как продолжение нашего файла
			core.freeSectors--;                                // Декрементируем кол-во свободных секторов
			core.cursorPosition = HANDLER_SIZE;                // Задаем смещение на размер заголовка и номера от начала нового сектора
			//Вычисляем адрес для записи
			address = FS_SECTOR_SIZE * core.currentFileSector + core.cursorPosition;
		    // Теперь все готово к записи
		}

		// Пишем в файл, и делаем инкремент смещения от начала сектора
		if (buffer[i] != 0xFF)
		{
			writeMemory(address, &buffer[i], 1);
			core.cursorPosition++;
		}
	}
}



/***************************************************************************************************
	LogFs_findFile - Функция поиска файлов в директории
***************************************************************************************************/
LogFs_Status LogFs_findFile(LogFs_CMD cmd)
{
	uint32_t           address;            // Вычисляемый адрес для чтения                     
	uint8_t            buffer[2];          // Буфер для чтения заголовка и номера файла
	uint32_t           i;                  // Счеттчик циклов
	static uint32_t    FileCount = 0;      // Количество просмотренных файлов

	// Если файлы отсутсвуют или система не инициализированна, то нечего искать
	if (core.files <= 0 || (core.state != FS_INIT_DONE && core.state != FS_FILE_OPEN))
		return FS_ERROR;

	// Посмотрим, что за команда
	// Если структура не была проинициализирована и вдруг приходит команда NEXT_FILE (Которая должна приходить только после FIRST_FILE)
	// Это ошибка
	if (cmd == NEXT_FILE && fileSelector.state != FS_INIT_DONE)
		return FS_ERROR;

	// Если в директории только один файл, и тот открыт на запись, то данные core.firstFileSectors
	// и core.firstFileBegin, оказываются неинициализированы, в этом случае маскируем запрос первого файла
	// запросом последнего, так как в данном случае это один и тот же файл. 
	else if (cmd == FIRST_FILE && core.files == 1 && core.state == FS_FILE_OPEN)
	{
		fileSelector.size = 0;
		fileSelector.id = 0;
		fileSelector.sectors = core.lastFileSectors;
		fileSelector.begin = core.lastFileBegin;

		// Сбрасываем счетчик просмотренных файлов
		FileCount = core.files - 1;
	}
	// Команда на запрос информации о самом старом файле в директории, равносильно команде на инициализацию структуры (отсчетной точкой будет старый файл)
	else if (cmd == FIRST_FILE)
	{
		// Сбрасываем и инициализируем структуру работы с файлами
		fileSelector.size = 0;
		fileSelector.id = 0;
		fileSelector.sectors = core.firstFileSectors;
		fileSelector.begin = core.firstFileBegin;

		// Сбрасываем счетчик просмотренных файлов
		FileCount = 0;
	}
	// Команда на запрос информации о самом новом файле в директории
	else if (cmd == LAST_FILE)
	{
		fileSelector.size = 0;
		fileSelector.id = 0;
		fileSelector.sectors = core.lastFileSectors;
		fileSelector.begin = core.lastFileBegin;

		// Сбрасываем счетчик просмотренных файлов
		FileCount = core.files - 1;
	}
	// Переходим к следующему файлу, если структура была инициализирована (точка отсчета есть)
	else if (cmd == NEXT_FILE && fileSelector.state == FS_INIT_DONE)
	{
		fileSelector.size = 0;
		fileSelector.id = 0;

		// Переходим к началу следующего файла, отталкиваясь от сектора предыдущего и количества секторов которые он занимал 
		fileSelector.begin = (fileSelector.begin + fileSelector.sectors) % FS_SECTORS_NUM;

		// Теперь необходимо определить сколько секторов занимает этот файл
		for (i = 1; i < FS_SECTORS_NUM; i++)
		{
			address = FS_SECTOR_SIZE * (fileSelector.begin + i);
			// Контролируем переходы кольцевого буфера (чтобы избежать переполнения и обращения по несуществующему адресу)
			address = address % (FS_SECTORS_NUM * FS_SECTOR_SIZE);
			// Будем читать заголовки секторов после StartSector пока не найдем FILE_EXIST_HANDLER - признак начала следующего файла
			readMemory(address, buffer, 2);
			if (*(uint16_t*)(buffer) == FILE_EXIST_HANDLER || *(uint16_t*)(buffer) == 0xFFFF)
				break;
		}
		// Фиксируем число таких секторов
		fileSelector.sectors = i;
	}
	// Иначе команда неопознана - возвращаем ошибку
	else
		return FS_ERROR;

	// Получаем адрес сектора расположения файла
	address = FS_SECTOR_SIZE * fileSelector.begin;

	// Проверим присутсвует ли по этому адресу заголовок начала файла
	readMemory(address, buffer, 2);
	if (*(uint16_t*)(buffer) == FILE_EXIST_HANDLER)
		fileSelector.state = FS_INIT_DONE;
	else 
		return FS_ERROR; // Заголовка нет, файловая система содержит ошибку

	// Узнаем порядковый номер этого файла в директории
	address += 2;
	readMemory(address, buffer, 2);
	fileSelector.id = *(uint16_t*)(buffer);

	// Если файл содержится на нескольких секторах, сразу переходим в последний
	if (fileSelector.sectors > 1)
	{
		// Определяем адрес этого сектора
		address = FS_SECTOR_SIZE * (fileSelector.begin + fileSelector.sectors - 1);
		// Контролируем переходы кольцевого буфера (чтобы избежать переполнения и обращения по несуществующему адресу)
		address = address % (FS_SECTORS_NUM * FS_SECTOR_SIZE);
		// А счетчик байт файла инкрементируем на (FS_SECTOR_SIZE - HANDLER_SIZE) * (Количество занятых файлом секторов - 1)
		fileSelector.size = (FS_SECTOR_SIZE - HANDLER_SIZE) * (fileSelector.sectors - 1);
		// Смещаем адрес на 4 заголовочных байта
		address += HANDLER_SIZE;
	}
	// Если же файл содержится только в текущем секторе смещаем адрес еще на 2 байта (от номера файла; на первый байт данных)
	else
		address += 2;

	// Дальше начинаем искать конец файла
	for (i = 0; i < FS_SECTOR_SIZE - 4; i++)
	{
		// Будем считывать байт за байтом из этого сектора и смотреть не упёрлись ли мы в конец (0xFF - форматированная ячейка)
		readMemory(address, &buffer[0], 1);
		// Если конец файла, то выходим
		if (*(uint8_t*)(buffer) == 0xFF)
			break;
		// Если попали сюда, то полученный байт не признак конца и нужно инкрементировать счетчик байт и адрес
		address++;
		fileSelector.size++;
	}
	// Инкрементируем счетчик просмотренных файлов, так как если мы дошли сюда, значит файл просмотрен
	FileCount++;
	// Проверяем все ли файлы в хранилище были просмотрены
	if (core.files <= FileCount)
		return FS_FILE_SELECTOR_AT_END;
	else
		return FILE_SELECTOR_NOT_AT_END;
}



/***************************************************************************************************
	LogFs_findFileByNum - Функция осуществляет поиск файла по номеру.
***************************************************************************************************/
LogFs_Status LogFs_findFileByNum(uint16_t id)
{
	uint16_t files = 0;    // Количество файлов в хранилище
	uint16_t minId;    // Минимальный порядковый номер среди файлов 
	uint16_t maxId;    // Максимальный порядковый номер среди файлов
	uint16_t i;            // Счетчик циклов


	// Если файлы отсутсвуют или система не инициализированна, то нечего искать
	if (core.files <= 0 || (core.state != FS_INIT_DONE && core.state != FS_FILE_OPEN))
		return FS_ERROR;

	// Проверим существует ли такой номер
	// Посмотрим порядковый номер самого свежего файла (номер должен быть самым большим)
	LogFs_findFile(LAST_FILE);
	maxId = LogFs_getFileID();

	// Посмотрим порядковый номер самого старого файла (номер должен быть самым маленьким)
	LogFs_findFile(FIRST_FILE);
	minId = LogFs_getFileID();

	// Номер запрашиваемого файла должен принадлжеать данному диапазону, иначе ошибка - файл не найден
	if (id > maxId || id < minId)
		return FS_ERROR;

	// Получим число файлов в хранилище
	files = LogFs_getFileNumber();

	for (i = 0; i < files; i++)
	{
		if (i == 0)
			LogFs_findFile(FIRST_FILE);
		else
			LogFs_findFile(NEXT_FILE);
		// Сверяем номер файла. Если совпадает файл найден можно выходить
		if (LogFs_getFileID() == id)
			return FS_SUCCESS;
	}
	// Если дошли сюда, значит файл не найден - ошибка
	return FS_ERROR;
}



/***************************************************************************************************
	LogFs_read - Функция чтения информации из файлов. Должна запускаться только после функции
	LogFs_findFile(), поскольку эта функция и позволяет нам определить какой файл будем
	читать. То, какой файл будем читать содержится в структуре fileSelector.
***************************************************************************************************/
LogFs_Status LogFs_read(uint8_t* buffer, uint32_t position, uint32_t size)
{
	uint32_t address;     // Адрес чтения 
	uint32_t i;           // Счетчик циклов
	uint32_t sector;      // Номер сектора от начала файла

	if (core.state == FS_NOT_INIT || core.files <= 0)
		return FS_ERROR;

	// Проверим корректность параметров, и запретим чтение за пределами файла
	if (position + size > fileSelector.size)
		return FS_ERROR;


	// Определяем к какому сектору файла относится первый читаемый байт
	sector = position / (FS_SECTOR_SIZE - HANDLER_SIZE);

	// Получаем текущий адрес ячейки для чтения
	// Сначала адрес нужного сектора с контролем переходов
	address = (FS_SECTOR_SIZE * (fileSelector.begin + sector)) % (FS_SECTOR_SIZE * FS_SECTORS_NUM);
	// Затем задаем необходимое смещение от начала сектора
	address += 4 + (position % (FS_SECTOR_SIZE - HANDLER_SIZE));

	// Начинаем побайтово читать файл
	for (i = 0; i < size; i++)
	{
		// Читаем байт
		readMemory(address, &buffer[i], 1);
		// Инкрементируем адрес с контролем перехода кольцевого буфера
		address = (address + 1) % (FS_SECTOR_SIZE * FS_SECTORS_NUM);
		// Проверим, вдруг адрес указывает на первые 4 байта заголовка сектора
		if (address % FS_SECTOR_SIZE == 0)
		{
			// Они нам не нужны, поэтому сразу перепрыгиваем на 4 байта вперед
			address += 4;
		}
	}
	return FS_SUCCESS;
}

